#!/usr/bin/python3
import argparse
import json
import pickle
import subprocess
import time
from os.path import expanduser

# these are used to determine display order
setups = {
    "dual-big-monitors": [
        "5CDE6E08-A34A-E536-F9F2-5D47625D75BF",
        "0741A56E-8E6A-8BEE-9DE9-5EAD44464C53",
    ],
    "laptop-work": ["26F17565-E8B3-59AF-38BE-D0A6F0F61133"],
    "laptop-home": ["E5B6EA75-FD04-E007-27FB-AED92723DB84"],
}

ignore_messages = [
    "acting space is already located on the given display.",
    "cannot focus an already focused space.",
]
# TODO: need to handle following errors:
"acting space is the last user-space on the source display and cannot be destroyed."
"acting space is the last user-space on the source display and cannot be moved."


def yabai_message(*msg):
    t = time.process_time()
    try:
        ret = subprocess.run(["yabai", "-m", *msg], capture_output=True)
        if ret.returncode:
            err_msg = ret.stderr.decode().strip()

            if err_msg not in ignore_messages:
                raise Exception(err_msg)
            else:
                print(f"While running {msg} we received error: {err_msg}")

        return ret.stdout.decode()
    finally:
        elapsed_time = time.process_time() - t
        print(f"{msg} {elapsed_time * 1000:.2f} ms")


def yabai_query(domain):
    return json.loads(yabai_message("query", "--{}".format(domain)))


def find_all(objects, key, value):
    return (obj for obj in objects if obj[key] == value)


def find_one(objects, key, value):
    try:
        return next(find_all(objects, key, value))
    except StopIteration:
        return


class WindowManager:
    yabai_states = {"spaces": [], "displays": [], "windows": []}
    yabaictl_states = {"recent": 0}
    yabai_cache_path = expanduser("~/.cache/yabai")
    yabaictl_cache_path = expanduser("~/.cache/yabaictl")

    NUM_SPACES = 10

    def __init__(self):
        self.found_setup = False
        self.refresh_state()

    @property
    def spaces(self):
        return self.yabai_states["spaces"]

    @property
    def displays(self):
        return self.yabai_states["displays"]

    @property
    def windows(self):
        return self.yabai_states["windows"]

    @property
    def num_displays(self):
        return len(self.displays)

    @property
    def num_spaces(self):
        return len(self.spaces) - 1

    @property
    def num_windows(self):
        return len(self.windows)

    @property
    def unlabeled_spaces(self):
        return list(find_all(self.spaces, "label", ""))

    @property
    def visible_spaces(self):
        return list(find_all(self.spaces, "visible", 1))

    @property
    def focused_space(self):
        return find_one(self.spaces, "focused", 1)

    @property
    def focused_space_num(self):
        label = self.focused_space["label"]
        # Strip the leading 's'
        return int(label[1:])

    @property
    def display_uuids(self):
        return [display["uuid"] for display in self.displays]

    @property
    def window_ids(self):
        return [window["id"] for window in self.windows]

    def find_monitor_setup(self):
        found_setup = False
        for setup in setups.values():
            if set(self.display_uuids) == set(setup):
                found_setup = True
                for ix, uuid in enumerate(setup):
                    self.find_display(uuid=uuid)["location"] = ix
        return found_setup

    def refresh_state(self):
        self.yabai_states["spaces"] = yabai_query("spaces")
        self.yabai_states["displays"] = yabai_query("displays")
        self.yabai_states["windows"] = yabai_query("windows")
        self.yabaictl_states = self.load_yabaictl_states()

        if not self.find_monitor_setup():
            raise Exception("unidentified monitor setup")

    def label_space(self, space_index, label):
        yabai_message(
            "space", f"{space_index}", "--label", self._space_label(label),
        )

    def swap_context(self):
        """Swap spaces between the first and second spaces for each display."""
        for i in range(1, self.num_displays + 1):
            first = self.find_space(i)
            second = self.find_space(i + self.num_displays)
            self.label_space(first["index"], i + self.num_displays)
            self.label_space(second["index"], i)
        self.refocus_first_spaces()

    def save_states(self):
        self.save_yabai_states()
        self.save_yabaictl_states()

    def save_yabai_states(self):
        with open(self.yabai_cache_path, "wb") as f:
            pickle.dump(self.yabai_states, f)

    def load_yabai_states(self):
        try:
            with open(self.yabai_cache_path, "rb") as f:
                return pickle.load(f)
        except FileNotFoundError:
            return {"spaces": [], "displays": [], "windows": []}

    def save_yabaictl_states(self):
        with open(self.yabaictl_cache_path, "wb") as f:
            pickle.dump(self.yabaictl_states, f)

    def load_yabaictl_states(self):
        try:
            with open(self.yabaictl_cache_path, "rb") as f:
                return pickle.load(f)
        except FileNotFoundError:
            return {"recent": 0}

    def find_display(self, display=None, index=None, uuid=None):
        """

        Parameters
        ----------
        display :
             Human identifiable display index (based on display order)
        index :
             System managed display index (based on returned value from yabai)
        uuid :
             System managed display UUID

        Returns
        -------

        """
        if display is not None:
            val = display
            key = "location"
        elif uuid is not None:
            val = uuid
            key = "uuid"
        elif index is not None:
            val = index
            key = "index"

        return find_one(self.displays, key, val)

    def find_space(self, space=None, index=None):
        """

        Parameters
        ----------
        space :
             Human identifiable space index. Can be just number or label (s<number>)
        index :
             System managed space index (based on returned value from yabai)

        Returns
        -------

        """
        if space is not None:
            # ensure we do the right thing whether a label or just number is provided
            val = self._space_label(space)
            key = "label"
        elif index is not None:
            val = index
            key = "index"

        return find_one(self.spaces, key, val)

    def _space_label(self, space):
        if "s" in str(space):
            return space
        return f"s{space}"

    def display_for_space(self, space):
        return (space - 1) % self.num_displays

    def focus_space(self, space):
        if space == "recent":
            space = self.yabaictl_states["recent"]
        if space == "next":
            space = self.focused_space_num + self.num_displays
            if space > self.NUM_SPACES:
                space = space % self.NUM_SPACES
        if space == "prev":
            space = self.focused_space_num - self.num_displays
            if space < 1:
                space = space + self.NUM_SPACES
        self.yabaictl_states["recent"] = self.focused_space_num
        space = int(space)
        # TODO fix this for > 2 displays
        if self.num_displays == 2:
            if space % 2 == 0:
                space_label = self._space_label(space - 1)
            else:
                space_label = self._space_label(space + 1)
            yabai_message("space", "--focus", space_label)
        space_label = self._space_label(space)
        yabai_message("space", "--focus", space_label)

    def _operate_window(self, operation, direction):
        """Move focus using `yabai -m window --focus` but allow moving across displays
        when using east or west."""
        try:
            yabai_message("window", operation, str(direction))
        except Exception as e:
            # The second case is true if the space has no windows
            if f"could not locate a {direction}ward managed window." in str(
                e
            ) or "could not locate the selected window." in str(e):
                """find next display in {direction}, then find active space in that
                display, then focus first(east)/last(west) window in that space."""
                next_space = self._next_space(direction)
                if not next_space:
                    raise
                key = (
                    "last-window"
                    if direction == "west"
                    else "first-window"
                    if direction == "east"
                    else ""
                )
                if self.num_displays == 1:
                    next_window = self.focused_space.get(key)
                    yabai_message("window", operation, str(next_window))
                    return

                if operation == "--focus":
                    if len(next_space.get("windows")) == 0:
                        # If the next display is empty, just wrap around the
                        # current display
                        next_window = self.focused_space.get(key)
                    else:
                        next_window = next_space.get(key)
                    yabai_message("window", operation, str(next_window))
                    return

                # In swap or warp with multiple displays if we get here
                if len(next_space.get("windows")) == 0:
                    # If the next display is empty, just send the window there
                    next_window = self.focused_space.get(key)
                    yabai_message("window", "--space", next_space.get("label"))
                else:
                    next_window = next_space.get(key)
                    yabai_message("window", operation, str(next_window))
                yabai_message("space", "--focus", next_space.get("label"))


    def focus_window(self, direction):
        """Move focus using `yabai -m window --focus` but allow moving across displays
        when using east or west."""
        self._operate_window("--focus", direction)

    def swap_window(self, direction):
        """Swap window using `yabai -m window --swap` but allow moving across displays
        when using east or west."""
        self._operate_window("--swap", direction)

    def warp_window(self, direction):
        """warp window using `yabai -m window --warp` but allow moving across displays
        when using east or west."""
        self._operate_window("--warp", direction)

    def _next_space(self, direction):
        current_space_num = self.focused_space_num

        # My main window is on the right
        if direction == "east":
            if current_space_num % self.num_displays == 0:
                next_space_num = current_space_num - 1
            else:
                next_space_num = current_space_num + 1
        elif direction == "west":
            if current_space_num % self.num_displays == 0:
                next_space_num = current_space_num - 1
            else:
                next_space_num = current_space_num + 1
        else:
            return

        return self.find_space(space=f"s{next_space_num}")

    def move_space_to_display(self, space, display):
        display_index = self.find_display(display=display)["index"]

        yabai_message(
            "space", self._space_label(space), "--display", f"{display_index}",
        )

    def move_window_to_space(self, window, space):
        yabai_message("window", str(window), "--space", self._space_label(space))

    def remove_unnecessary_spaces(self):
        while self.num_spaces > self.NUM_SPACES:
            index = self.unlabeled_spaces[0]['index']
            yabai_message("space", str(index), "--destroy")
            self.refresh_state()

    def ensure_spaces(self):
        if self.num_spaces < self.NUM_SPACES:
            for i in range(self.num_spaces, self.NUM_SPACES):
                yabai_message("space", "--create")

    def ensure_labels(self):
        self.label_space(1, "reserved")
        wanted_labels = set(self._space_label(i) for i in range(1, self.NUM_SPACES + 1))
        existing_labels = set(space["label"] for space in self.spaces)

        for ix, missing_label in enumerate(sorted(wanted_labels - existing_labels)):
            self.label_space(self.unlabeled_spaces[ix]["index"], missing_label)

    def refocus_first_spaces(self):
        for i in range(1, self.num_displays + 1):
            self.focus_space(i)

    def reorganize_spaces(self):
        old_states = self.load_yabai_states()

        for space_index in range(1, self.NUM_SPACES + 1):
            self.move_space_to_display(
                space_index, self.display_for_space(space_index),
            )

        for space in old_states["spaces"]:
            for window in space["windows"]:
                if window in self.window_ids:
                    if space["label"]:
                        self.move_window_to_space(window, space["label"])

        # after re-shuffling, focus the "default" spaces
        # self.refocus_first_spaces()

    def sort_spaces(self):
        for i in range(1, self.num_displays + 1):
            spaces = list(find_all(self.spaces, "display", i))
            sorted = False
            # Use bubble sort since we can only use next and prev to rearrange
            # spaces
            while not sorted:
                sorted = True
                for j in range(1, len(spaces) - 1):
                    label_a = int(spaces[j]["label"][1:])
                    label_b = int(spaces[j+1]["label"][1:])
                    if label_a > label_b:
                        yabai_message("space", "--focus", self._space_label(label_a))
                        yabai_message("space", "--move", "next")
                        spaces[j], spaces[j+1] = spaces[j+1], spaces[j]
                        sorted = False

    def update_spaces(self):
        self.ensure_spaces()
        self.refresh_state()

        self.ensure_labels()
        self.refresh_state()

        self.reorganize_spaces()
        self.refresh_state()

        self.remove_unnecessary_spaces()
        self.refresh_state()

        self.sort_spaces()
        self.refresh_state()


def add_subcommand(sub, func, subcommand_name, subcommand_args=[]):
    parser = sub.add_parser(subcommand_name)
    parser.set_defaults(func=func)
    for arg in subcommand_args:
        parser.add_argument(arg)


def parse_args(wm):
    parser = argparse.ArgumentParser()
    sub = parser.add_subparsers()

    add_subcommand(sub, wm.update_spaces, "update-spaces")
    add_subcommand(sub, wm.swap_context, "swap-context")
    add_subcommand(sub, wm.focus_space, "focus-space", ["space"])
    add_subcommand(sub, wm.focus_window, "focus-window", ["direction"])
    add_subcommand(sub, wm.swap_window, "swap-window", ["direction"])
    add_subcommand(sub, wm.warp_window, "warp-window", ["direction"])

    args = vars(parser.parse_args())
    return args.pop("func"), args


if __name__ == "__main__":
    wm = WindowManager()
    func, args = parse_args(wm)
    func(**args)

    wm.save_states()
